#!/usr/bin/env python3

"""a very simple matched-filter search for sine-Gaussian signals in stationary white noise
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os

import utils
np = utils.np

from argparse import ArgumentParser

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('data', type=str)

parser.add_argument('--fo', default=20.0, type=float)
parser.add_argument('--tau', default=2.0, type=float)

parser.add_argument('--tukey-alpha', default=0.25, type=float)

parser.add_argument('--snr-thr', default=1.0, type=float)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

#-------------------------------------------------

# load time-series data from disk
time, data = utils.load_data(args.data, verbose=args.verbose)

#------------------------

if args.verbose:
    print('estimating time-domain noise properties assuming stationary, white Gaussian noise')
sigma = np.std(data) ### assumes stationary, white Gaussian noise

#------------------------

# figure out relevant parameters for FFT and transform the data

Nsmp = len(time)

dt = time[1]-time[0]
duration = dt*Nsmp

nyquist = 0.5/dt # 0.5*sample_rate
df = 1./duration

# now compute the windowing function

if args.verbose:
    print('computing Tukey window function with alpha=%.3f' % args.tukey_alpha)

window = utils.tukey_window(Nsmp, alpha=args.tukey_alpha)

if args.verbose:
    print('plotting data and window function')
fig = utils.plot_data(time, data, [], color='k')
fig = utils.plot_data(time, max(np.abs(fig.gca().get_ylim()))*window, [], color='b', fig=fig)

utils.savefig(
    os.path.basename(__file__) + '-data.png',
    fig,
    verbose=args.verbose,
)

# compute Fourier Transform of data

if args.verbose:
    print('computing FFT of windowed data')

dfd, freq = utils.dft(data*window, dt)

#------------------------

# generate a freq-domain waveform with the known parameters: (fo, tau)
if args.verbose:
    print('generating template with fo=%.3f and tau=%.3f' % (args.fo, args.tau))

A = 1.0  # default parameters for the template
to = 0.0
phio = 0.0

hfd = utils.sine_gaussian_freq_domain(freq, A, to, args.fo, phio, args.tau)

### normalize template
if args.verbose:
    print('normalizing the template')

hfd /= (4 * np.trapz((hfd.real**2 + hfd.imag**2) / sigma**2, x=freq))**0.5

#------------------------

# compute SNR time series
if args.verbose:
    print('computing complex filter response as a function of time via FFT')

# this can be computed via an DFT

snrtd_real = utils.idft(4 * np.conjugate(dfd) * hfd / sigma**2, dt)[0][::-1]
snrtd_imag = utils.idft(-4j * np.conjugate(dfd) * hfd / sigma**2, dt)[0][::-1]

# take the absolute magnitude
snrtd = (snrtd_real**2 + snrtd_imag**2)**0.5

#------------------------

# identify peaks
if args.verbose:
    print('identifying triggers (local maxima in SNR time-series)')

local_max = (snrtd[:-2] < snrtd[1:-1]) & (snrtd[1:-1] > snrtd[2:])
peak_inds = np.arange(1,Nsmp-1)[local_max]

# apply a basic threshold
loud_inds = peak_inds[snrtd[peak_inds] > args.snr_thr]

if args.verbose:
    print('    found %d local maxima' % len(peak_inds))
    print('    found %d local maxima with snr > %.3f' % (len(loud_inds), args.snr_thr))

# make a plot
if args.verbose:
    print('plotting data and snr time series')

fig = utils.plot_data(time, snrtd, [], color='r', ylabel='$\\rho$')
ax = fig.gca()
ylim = ax.get_ylim()
for t in time[loud_inds]:
    ax.plot([t]*2, ylim, color='k', alpha=0.25, zorder=-10)
ax.set_ylim(ylim)

utils.savefig(
    os.path.basename(__file__) + '-snr.png',
    fig,
    verbose=args.verbose,
)

for ind in loud_inds:
    sel = (time[ind]-args.tau*5 <= time) & (time <= time[ind]+args.tau*5)

    fig = utils.plot_data(time[sel], snrtd[sel], [], color='r')
    utils.plot_data(time[sel], snrtd_real[sel], [], color='b', fig=fig)
    utils.plot_data(time[sel], snrtd_imag[sel], [], color='c', ylabel='$\\rho$', fig=fig)

    ax = fig.gca()
    ylim = ax.get_ylim()
    ax.plot([time[ind]]*2, ylim, color='k', alpha=0.25, zorder=-10)
    ax.set_ylim(ylim)

    utils.savefig(
        os.path.basename(__file__) + '-snr-peak-%09d.png' % ind,
        fig,
        verbose=args.verbose,
    )

#------------------------

# estimate statistical significance of each trigger
if args.verbose:
    print('estimating statistical significance of each trigger')

raise NotImplementedError('''\
generate a lot of mock noise
compute filter responses for each of these realizations
make a cumulative histogram of the SNRs observed
''')
